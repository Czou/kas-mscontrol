   ------
   Kurento Android media management
   ------
   ------
   Date
   ------
   
Kurento Android media management

* Introduction
  
   There is a tradeoff between video quality and  computational resources 
   required for media processing. This is specially true for mobile platforms,
   where CPU, memory and bandwidth are very limited. 
   
   Assumed it is not possible to achieve desired media quality, the priority
   becomes to optimize resources to get the maximum possible quality, although this
   is a very fuzzy concept that requires better definition. Video quality can be 
   quantitatively characterized through terms like the ones below:
   	
   	* Dimension
   	* Quantization step
   	* Sample rate
   	* Transmission latency
   	
   Many others can be used. The important thing is that a limited amount of 
   resources causes a tradeoff between above attributes and that makes necessary a
   decision on what to prioritize.


* Frame adaptation queue

	Kurento Android SDK is specially conceived for conversational services, and consequently
	latency becomes the main quality attribute. There is a natural tradeoff between latency and
	sensitivity to jitter. It is easy to understand that when buffers are reduced in transmission
	pipes, the stream is much more affected by delays in packets. This causes a quality degradation
	in term of video continuity, as probability of frame loss increases.
	
	The frame adaptation queue is a FIFO buffer of <N> positions that discards oldest frames when full.
	It is specially designed to achieve following objectives:
	
		* Adapt generation and transmission frame rates
		
		* Reduce jitter effects to improve video continuity for a given latency.
		
	The adaptation queue operates between the video source and sink. It receives frames from the camera
	at generation rate and delivers to the network at target frame rate <Tfr>. There are two possible
	operational modes
	
		* When generation rate is lower than target rate, the actual transmission rate will
		equal generation. In this operation mode the queue is empty as frames are sent as they 
		are received. Reception device is exposed completelly to jitter effect.
		
		* When generation rate (<Gfr>) is higher than target rate, one frame each <Gfr/Tfr>	has to be 
		discarded. In this operation mode the queue is full and latency increases by a value <N> á 1/Tfr.
		Transmission time for next frame is calculated as 
		
			[<tn = 1/Tfr á N + t_(n-N)>]
				* <tn>: Next transmission time
				* <N>: Queue size
				* <t_(n-N)>: Transmission time of frame <n-N>
			
		 It has been found that Android camera is quite an important source of jitter. Video is delivered
		 at 30 frames per second, but with high variability. Above formula is actually a jitter low 
		 pass filter that improves time slots variability and hence a smooth video stream with the frame
		 rate required for transmission.

	
* Optimal codec configuration	

	Based in the estimated bandwidth of the active interface it is possible to optimize video quality,
	providing a proper set of codec parameters for a given target frame rate and frame size requested 
	by user application. 
	
	Frame rate and  bandwidth are directly related through the frame size. This is the mechanism
	used by codecs to determine the compression required per frame, based in a target <bit_rate> and
	<frame_rate>. As an example, to obtain 384000 bps(bits per second) with 15 fps(frames per second),
	encoded frames must have a medium size of 25600 bits
	
+---
384000 bps / 15 fps = 25600 bpf (bits per frame)
+---
	
	Codecs are configured with a target <frame_rate> and <bit_rate>, but codification is quite a difficult
	task and this target values are just tentative values. Next equation provides a way to estimate the
	real bit_rate of a stream.
+---
real_bitrate = K * target_bitrate/targer_framerate * real_framerate
+---
	
	<K> is a correction factor associated to compression behavior. Generate frames with a 
	precise size to meet target bandwidth requires to much computational resources, so 
	normally frames are smaller and hence real <bit_rate>.
	
	A <real_framerate> must also be considered, as it can happen that the codec is unable to generate
	frames fast enough (in less than 1/<Tfr>).
	
	Kurento Android SDK dynamically measures <K> factor and real <frame_rate> and adjust target <frame_rate>
	and target <bit_rate>, so the real <bit_rate> approaches the target one, improving this way the video
	quality as resources are optimized.

